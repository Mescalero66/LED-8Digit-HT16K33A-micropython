from ht16k33 import HT16K33
import time
from machine import I2C, Pin

class HT16K33Segment8(HT16K33):
    """
    MicroPython driver for 8-digit 7-segment LED displays using the HT16K33 controller.
    Includes decimal points, extended charset, scrolling text, and justification.
    """

    POS = [0, 2, 4, 6, 8, 10, 12, 14]

    CHARSET = [
        0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,  # 0–9
        0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x3D, 0x76, 0x06, 0x1E,  # A–J
        0x75, 0x38, 0x37, 0x54, 0x5C, 0x73, 0x67, 0x50, 0x6D, 0x78,  # K–T
        0x3E, 0x1C, 0x2A, 0x76, 0x6E, 0x5B,                          # U–Z
        0x00, 0x40, 0x63, 0x48, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00   # space, -, °, =, _
    ]

    CHAR_LOOKUP = {
        0x20: 36,  # space
        0x2D: 37,  # dash
        0xB0: 38,  # degree °
        0x2A: 38,  # * = degree symbol
        0x3D: 39,  # equal =
        0x5F: 40   # underscore
    }

    def __init__(self, i2c, i2c_address=0x70):
        self.buffer = bytearray(16)
        super().__init__(i2c, i2c_address)

    def clear(self):
        for i in range(16):
            self.buffer[i] = 0x00
        return self

    def set_digit(self, digit, char, dot=False):
        assert 0 <= digit < 8, "Digit must be 0-7"
        code = ord(char.upper()) if isinstance(char, str) else char
        index = self.CHAR_LOOKUP.get(code, None)
        if index is None:
            if 48 <= code <= 57:       # 0–9
                index = code - 48
            elif 65 <= code <= 90:     # A–Z
                index = code - 55
            else:
                index = 36  # space fallback
        seg = self.CHARSET[index]
        if dot:
            seg |= 0x80
        self.buffer[self.POS[digit]] = seg
        return self
    
    def show_string(self, s):
        self.clear()
        i = 0
        skip = False
        for pos in range(8):
            if i >= len(s):
                break
            c = s[i]
            if c == '.' and pos > 0:
                self.buffer[self.POS[pos - 1]] |= 0x80
                skip = True
            else:
                self.set_digit(pos, c)
                skip = False
            i += 0 if skip else 1
        self.draw()
        return self

    def show_string_justified(self, s, justify='left'):
        self.clear()
        i = 0
        skip = False
        display_chars = []

        # Parse string and merge dots
        while i < len(s):
            if s[i] == '.' and display_chars:
                display_chars[-1] = (display_chars[-1][0], True)
            else:
                display_chars.append((s[i], False))
            i += 1

        if len(display_chars) > 8:
            display_chars = display_chars[:8]

        pad = 8 - len(display_chars)
        if justify == 'right':
            display_chars = [(" ", False)] * pad + display_chars
        elif justify == 'center':
            left = pad // 2
            right = pad - left
            display_chars = [(" ", False)] * left + display_chars + [(" ", False)] * right
        else:  # default left
            display_chars += [(" ", False)] * pad

        for pos, (char, dot) in enumerate(display_chars):
            self.set_digit(pos, char, dot)

        self.draw()
        return self
    
    def show_number(self, value):
        fmt = "{:.6g}".format(value)
        self.show_string(fmt)

    def show_number_justified(self, value, justify='right'):
        fmt = "{:.6g}".format(value)
        self.show_string_justified(fmt, justify)

    def scroll_string(self, s, delay=0.25, repeat=1):
        s = "        " + s + "        "
        for _ in range(repeat):
            for i in range(len(s) - 7):
                self.show_string(s[i:i + 8])
                time.sleep(delay)

    def scroll_string_justified(self, s, delay=0.25, repeat=1):
        s = "        " + s + "        "
        for _ in range(repeat):
            for i in range(len(s) - 7):
                self.show_string_justified(s[i:i + 8])
                time.sleep(delay)

    def blink_digit(self, digit, duration=0.5, times=3):
        """
        Blink a specific digit on and off.

        Args:
            digit (int): The digit index (0-7).
            duration (float): Time (in seconds) between on/off.
            times (int): Number of blink cycles.
        """
        assert 0 <= digit < 8, "Digit must be 0-7"
        original = self.buffer[self.POS[digit]]

        for _ in range(times):
            self.buffer[self.POS[digit]] = 0x00
            self.draw()
            time.sleep(duration)
            self.buffer[self.POS[digit]] = original
            self.draw()
            time.sleep(duration)